<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C 预处理器</title>
      <link href="/blog/2021/09/27/C%20Preprocessor/"/>
      <url>/blog/2021/09/27/C%20Preprocessor/</url>
      
        <content type="html"><![CDATA[<h1 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h1><p>C 处理器其实也有很多技巧和注意点，我大致看过了所有section，对于某些地方，我还是没有理解，例如tokenization处理流程，我并没看懂。大致翻译了一部分，后面附上官网地址用于以后查阅。希望，后面能逐步理解。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>C预处理器（命令行 cpp)是一个宏处理器。C编译器会自动调用它来预处理你的程序。C预处理器只用于C、c++和Objective-C源代码。例如，你用它预处理makefile文件，那么所有的tab符都会被移除，从而导致Makefile不能工作。</p><p>话虽如此，你可以在c语言之外的地方使用cpp。其他类似algoli的编程语言通常是安全的(Ada等)。-traditional-cpp模式保留更多的空白，否则更宽容。许多问题可以通过编写C或c++风格的注释而不是本地语言注释来避免，并保持宏的简单性。</p><p>C预处理器在某些细节上有所不同。这本手册讨论了GNU C预处理器，它提供了ISO标准C特性的一个小超集。在它的默认模式下，GNU C预处理器不做标准要求的一些事情。这些特性很少被使用，并且可能会给程序的含义带来意想不到的变化。要获得严格的ISO标准C，您应该使用-std=c90、-std=c99、-std=c11或-std=c17选项，这取决于您想要的标准版本。要获得所有强制诊断，还必须使用-pedantic。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cpp -std&#x3D;c11 -pedantic [input]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CPP 默认使用UTF-8字符集，你可以通过-finput-charset= option 选项进行指定输入文件的字符集。</p><h2 id="初始处理"><a href="#初始处理" class="headerlink" title="初始处理"></a>初始处理</h2><p>CPP 会把输入文件加载到内存，然后按行进行处理。行结束标志<code>CR</code>,<code>CR LF</code>,<code>CR</code>.对于很长的一行可以用’&#39;进行换行处理（连续行），CPP会把以’&#39;结尾的连续行合并回一个很长的行，两个连续行合并中间不会插入空格，可以理解为直接字符串拼接。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">hi</span> <span class="token expression">hello</span><span class="token punctuation">\</span><span class="token expression">world</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>hi <span class="token operator">=</span> <span class="token string">"ni hao"</span><span class="token punctuation">;</span>\\宏hi 会预处理成helloworld，中间不会有空格    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>行注释’//‘,块注释’/* comments */‘。</p><h2 id="include-search-path"><a href="#include-search-path" class="headerlink" title="include search path"></a>include search path</h2><p>默认情况下，预处理器查找指令#include “file”的引号形式包含的头文件，首先相对于当前文件的目录，然后在标准系统目录的预配置列表中查找。例如，如果/usr/include/sys/stat.h包含#include “types.h”， GCC首先在/usr/include/sys中查找types.h，然后在它通常的搜索路径中查找。</p><p>对于尖括号形式#include <file>，预处理器的默认行为是只查看标准系统目录。确切的搜索目录列表取决于目标系统、GCC的配置方式以及它的安装位置。通过使用-v选项调用CPP，可以找到CPP版本的默认搜索目录列表. 例如：<code>cpp -v /dev/null -o /dev/null</code></p><p>您可以使用许多命令行选项向搜索路径添加额外的目录。最常用的选项是-Idir，它导致dir在当前目录(指令的引号形式)之后和标准系统目录之前搜索。您可以在命令行上指定多个-I选项，在这种情况下，目录将按照从左到右的顺序搜索。</p><p>如果你需要单独控制’ #include ‘指令的引号和尖括号形式的搜索路径，你可以使用-iquote和/或-isystem选项来代替-I。有关这些选项以及其他一般不太有用的选项的详细描述，请参阅调用。</p><p>如果在命令行中指定其他选项，比如-I，它会影响预处理器搜索头文件的位置，那么-v选项打印的目录列表会反映预处理器使用的实际搜索路径。</p><p>注意，您还可以使用- nodinc选项阻止预处理器搜索任何默认的系统头目录。当编译操作系统内核或其他不使用标准C库工具或标准C库本身的程序时，这是非常有用的。</p><h2 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a>函数宏</h2><p>您还可以定义一些宏，其使用方式类似于函数调用。这些被称为类函数宏。要定义一个类似函数的宏，你可以使用相同的’ #define ‘指令，但是在宏名称后面马上放一对括号。例如,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lang_init</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">c_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token function">lang_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     → <span class="token function">c_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数宏只有在名称后跟一对括号时才会展开。如果你只写名字，它就不需要写了。当您有一个同名的函数和一个宏，并且您有时希望使用该函数时，这是非常有用的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">foo</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token comment">/* optimized inline version */</span></span>…  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  funcptr <span class="token operator">=</span> foo<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，对<code>foo()</code>的调用将使用宏，但函数指针将获得实际函数的地址。如果要扩展宏，它将导致语法错误。如果在宏定义中的宏名和圆括号之间加空格，这就不会定义一个类函数宏，而是定义了一个类对象宏，其展开碰巧以一对圆括号开始。</p><h2 id="官网（可以当手册翻阅）"><a href="#官网（可以当手册翻阅）" class="headerlink" title="官网（可以当手册翻阅）"></a>官网（可以当手册翻阅）</h2><p><a href="https://gcc.gnu.org/onlinedocs/cpp/index.html#SEC_Contents">https://gcc.gnu.org/onlinedocs/cpp/index.html#SEC_Contents</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> C预处理器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ new操作符号的一些探索</title>
      <link href="/blog/2021/09/24/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/"/>
      <url>/blog/2021/09/24/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="new和delete-new-和delete"><a href="#new和delete-new-和delete" class="headerlink" title="new和delete new[]和delete[]"></a>new和delete new[]和delete[]</h1><h2 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h2><p>在C++中，new和delete是配对使用的。这两个操作符的作用是用来动态分配单个类型的对象。如果new 一个类对象，C++语言会自动插入默认构造函数的调用代码， delete一个类对象，C++语言会自动插入析构函数的调用代码。所以，如果这个类对象有继承关系，析构函数必须实现成虚函数（避免基类对象指针指向子类的时候，调用delete操作，如果析构函数不是虚函数，就只会调用基类的析构函数，子类就无法析构了）。</p><h2 id="new-和-delete-1"><a href="#new-和-delete-1" class="headerlink" title="new[] 和 delete[]"></a>new[] 和 delete[]</h2><p>为什么C++中有个new 和 delete后，为什么还来一对new[] 和 delete[]? 请看下面代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destruct"</span><span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    A <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    A <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span>    <span class="token comment">// delete a; malloc: *** error for object 0x101009208: pointer being freed was not allocated</span>    <span class="token keyword">delete</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span>a <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 <code>delete a</code>代码执行时候，会奔溃。 调用<code>delete (A*)((uint64_t)a - 8)</code>,可以正常析构数组的第一个A对象，后面99对象没有调用析构函数，只是被底层的free 函数回收了内存。</p><p>在我的x86_64 MAC电脑上，C++在调用new[]操作符号时候，会多分配一个8字节的空间，用来存放数着的size。然后把底层malloc函数返回的指针值加8后返回给我们代码。这样，用户调用 delete[]操作符号时候，会取出size，然后迭代进行析构，再减8字节后调用free释放内存。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写好一个bench_mark工具</title>
      <link href="/blog/2021/09/18/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AAbench-mark-%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2021/09/18/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AAbench-mark-%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="bench-mark"><a href="#bench-mark" class="headerlink" title="bench_mark()"></a>bench_mark()</h1><p>如何优雅的实现一个测试代码运行时间的<code>bench_mark</code>函数，talk is cheap, show me your code.</p><h3 id="bench-mark-h"><a href="#bench-mark-h" class="headerlink" title="bench_mark.h"></a>bench_mark.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">bench_mark_ </span><span class="token comment">//guard for #include usage</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">bench_mark_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>    <span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">&#123;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__GNUC__</span></span>        <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__format__</span><span class="token punctuation">(</span>printf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token keyword">void</span> <span class="token function">bench_mark</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">^</span>task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>    <span class="token punctuation">&#125;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">bench_mark</span><span class="token expression"><span class="token punctuation">(</span>t<span class="token punctuation">,</span>f<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">^</span>b<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> t<span class="token punctuation">;</span></span><span class="token punctuation">\</span>    <span class="token expression">b <span class="token operator">?</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span></span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>header 文件里面，在DEBUG环境下需要说明的是<code>__attribute__((__format__(printf, 2, 3)))</code>.  这个是编译器属性，可以提示编译器去检查<code>(&quot;%s,%d&quot;,&quot;hello&quot;,1)</code>类型匹配问题，同时给出warning.在RELEASE环境下，<code>bench_mark</code>函数会替换成一个宏，做到只执行工程中的代码，这样就剥离了时间测试相关的代码， 做到无入侵。</p><h3 id="bench-mark-m"><a href="#bench-mark-m" class="headerlink" title="bench_mark.m"></a>bench_mark.m</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">"bench_mark.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__GNUC__</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">likely</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">likely</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token keyword">void</span> <span class="token function">bench_mark</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">^</span>task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>format<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        va_list ap<span class="token punctuation">;</span>        <span class="token function">va_start</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">vsprintf</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> format<span class="token punctuation">,</span> ap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">va_end</span><span class="token punctuation">(</span>ap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        CFAbsoluteTime start <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CFAbsoluteTime delta <span class="token operator">=</span> <span class="token number">0.f</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">"Used time:(%.2lfs)-(%.5lfms) %s"</span><span class="token punctuation">,</span> delta<span class="token punctuation">,</span> delta <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>.m文件里面需要说明下，为什么加入likely。在bench_mark的使用场景下，block为nil的概率是零。这样可以充分利用CPU的冒险机制，做到更准的测试task中的运行时间。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre class="line-numbers language-objc" data-language="objc"><code class="language-objc">bench_mark(^&#123;    [self logicCode];&#125;, &quot;%s, %s&quot;,&quot;&gt;&gt; as filter key work&quot;, __FILE__);bench_mark(nil,&quot;Hi, boy~&quot;);bench_mark(nil,nil);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/liangxiuchen/bench_mark">https://github.com/liangxiuchen/bench_mark</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些好用的命令和工具</title>
      <link href="/blog/2021/09/18/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E5%92%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2021/09/18/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E5%92%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="工作中能提高效率的命令和工具"><a href="#工作中能提高效率的命令和工具" class="headerlink" title="工作中能提高效率的命令和工具"></a>工作中能提高效率的命令和工具</h1><h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><p>摘要：too long, don’t read(tldr)</p><p>好用之处：见名知意，在类Unix系统中一个非常重要的命令<code>man</code>，是大家每天工作都离不来的。但是，它所呈现的文档太详细，太长，导致我们无法高效的查询常用的命令。所谓的二八定律，被这个命令很好的诠释。</p><p>用法：tldr [命令]</p><p>官网：<a href="https://tldr.sh/">https://tldr.sh/</a></p><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>摘要：键位映射</p><ol><li>物理键盘上的Cap Lock键位几乎没什么作用，可以在系统设置-&gt;键盘设置中把它映射成CTRL键。</li><li>在.vimrc文件中用CTRL-j 组合来映射成ESC键位。</li></ol><p>这样处理了，就能大大提高Vim 编辑效率了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>野指针</title>
      <link href="/blog/2021/08/20/%E9%87%8E%E6%8C%87%E9%92%88/"/>
      <url>/blog/2021/08/20/%E9%87%8E%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><p>各位大佬在日常开发中，相信肯定遇到过野指针的crash。但是在C或者C++中野指针一定会导致奔溃吗？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//在堆上，分配一个int类型大的内存空间</span><span class="token keyword">void</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放pi指向的内存。delete 怎么知道需要回收多少内存，我们这里只传入了一个地址而已。</span><span class="token function">free</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//现在pi已经是悬挂的野指针了</span><span class="token keyword">int</span> <span class="token operator">*</span>p_i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>pi<span class="token punctuation">;</span><span class="token comment">//写一个野指针</span><span class="token operator">*</span>p_i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//读取一个野指针</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token operator">*</span>p_i<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p-%p:%d\n"</span><span class="token punctuation">,</span>pi<span class="token punctuation">,</span> p_i<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码会奔溃吗？小伙伴们可以尝试下。答案是这个case是肯定不会crash。为什么?</p><h2 id="内存访问原理"><a href="#内存访问原理" class="headerlink" title="内存访问原理"></a>内存访问原理</h2><p>首先，我们上层应用程序所得到的都是虚拟内存。当我们使用标准库中的<code>malloc</code>来分配内存的时候，标准库会调用操作系统的一个系统调用接口<code>brk(size_t)</code>，来向操作体系申请堆空间。此时，操作系统会分配一部分虚拟内存空间，并在内核进程记账。所以，当我们<code>free</code>了这块内存，其实仅仅只是像标准库说明了，我们释放了这片内存。这样，标准库可以在下次，重新分配这片内存给别的变量。但是在操作系统看来，这片内存还是被你的应用使用着。所以，当你用<code>*pi_i</code>去读取或者写入，都是合法的。所以，上面代码片段执行都是不会crash的。</p><h2 id="crash的场景"><a href="#crash的场景" class="headerlink" title="crash的场景"></a>crash的场景</h2><ul><li><code>free</code>重复调用。当你第一次调用<code>free</code>, 标准库会记账回收。此时，你再重复释放，标准库就会执行奔溃流程了。</li><li>这片内存别重新分配给了别的变量，然后野指针变量破坏了这部分数据，都可能造成段错误，非法指令等奔溃。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在利用指针的时候，养成释放了内存，对应变量也需要设成<code>nil</code>。 这样即使奔溃了，也好定位。不然的话，野指针能导致的crash有时候真的很难定位。</p>]]></content>
      
      
      <categories>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>始</title>
      <link href="/blog/2021/08/13/whishStart/"/>
      <url>/blog/2021/08/13/whishStart/</url>
      
        <content type="html"><![CDATA[<h1 id="致谢家人"><a href="#致谢家人" class="headerlink" title="致谢家人"></a>致谢家人</h1><p>已经做iOS开发快5年了，中间有成长也有迷惑。我想这是每一个IT人，只要你是搞技术的，都是需要不断学习。所以博客是最好的笔记本，在这里你可以分享你的认知。同时也是重温和巩固自己所学的。3年之前，我也是搭建过一个博客，但是那个博客我懒懒散散地写了几篇技术文章就没有再去更新过了。</p><p>这次我重构了，博客用来记录我平时的生活和学习。白驹过隙和4年前相比，我现在已经为人夫为人父。在此，我首先感谢我的老婆，为我生了一个那么可爱的儿子，感谢丈母娘辛苦带娃。好了，今天就止于此，博客始于此。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
